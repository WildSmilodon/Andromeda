Merge "oval.vtk";


sLarge=100.0; // Velikost elementa v krogli
sSmall=0.05; // Velikost elementa v krogli
rr=512.0; // radij krogle



// We first classify ("color") the surfaces by splitting the original surface
// along sharp geometrical features. This will create new discrete surfaces,
// curves and points.

//DefineConstant[
//    // Angle between two triangles above which an edge is considered as sharp
//    angle = {40, Min 20, Max 120, Step 1,
//      Name "Parameters/Angle for surface detection"},
//    // For complex geometries, patches can be too complex, too elongated or too
//    // large to be parametrized; setting the following option will force the
//    // creation of patches that are amenable to reparametrization:
//    forceParametrizablePatches = {1, Choices{0,1},
//      Name "Parameters/Create surfaces guaranteed to be parametrizable"},
//    // For open surfaces include the boundary edges in the classification process:
//    includeBoundary = 1,
//    // Force curves to be split on given angle:
//    curveAngle = 180
//  ];

//ClassifySurfaces{120 * Pi/180, 1, 1, 180 * Pi / 180};
  
  // Create a geometry for all the discrete curves and surfaces in the mesh, by
  // computing a parametrization for each one
//  CreateGeometry;
  
  // In batch mode the two steps above can be performed with `gmsh t13.stl
  // -reparam 40', which will save `t13.msh' containing the parametrizations, and
  // which can thus subsequently be remeshed.
  
  // Note that if a CAD model (e.g. as a STEP file, see `t20.geo') is available
  // instead of an STL mesh, it is usually better to use that CAD model instead of
  // the geometry created by reparametrizing the mesh. Indeed, CAD geometries will
  // in general be more accurate, with smoother parametrizations, and will lead to
  // more efficient and higher quality meshing. Discrete surface remeshing in Gmsh
  // is optimized to handle dense STL meshes coming from e.g. imaging systems
  // where no CAD is available; it is less well suited for the poor quality STL
  // triangulations (optimized for size, with e.g. v2ery elongated triangles) that
  // are usually generated by CAD tools for e.g. 3D printing.
  
  // Create a volume as usual
  //Surface Loop(1) = Surface{:};


//Physical Surface("paJUrticle") = {:};
// 

//+
//Physical Surface("particle") = {2, 3, 4, 5};
//Surface Loop(1) = Surface{:};
//Physical Surface("particle") = {:};
Physical Surface("particle") = {1};


// *********************************************************************
// **************** VELIKA KROGLA *********************************************
// *********************************************************************

Point(11) = {0, 0, 0, sLarge};
Point(12) = {-rr, 0, 0, sLarge};
Point(13) = {rr, 0, 0, sLarge};
Point(14) = {0, -rr, 0, sLarge};
Point(15) = {0, rr, 0, sLarge};
Point(16) = {0, 0, rr, sLarge};
Point(17) = {0, 0, -rr, sLarge};
Circle(101) = {13, 11, 15};
Circle(102) = {12, 11, 15};
Circle(103) = {12, 11, 14};
Circle(104) = {14, 11, 13};
Circle(105) = {16, 11, 13};
Circle(106) = {16, 11, 12};
Circle(107) = {12, 11, 17};
Circle(108) = {17, 11, 13};
Circle(109) = {15, 11, 16};
Circle(110) = {16, 11, 14};
Circle(111) = {14, 11, 17};
Circle(112) = {17, 11, 15};
Line Loop(113) = {109, 105, 101};
Surface(114) = {113};
Line Loop(115) = {102, 109, 106};
Surface(116) = {115};
Line Loop(117) = {107, 112, -102};
Surface(118) = {117};
Line Loop(119) = {112, -101, -108};
Surface(120) = {119};
Line Loop(121) = {106, 103, -110};
Surface(122) = {121};
Line Loop(123) = {110, 104, -105};
Surface(124) = {123};
Line Loop(125) = {111, -107, 103};
Surface(126) = {125};
Line Loop(127) = {108, -104, 111};
Surface(128) = {127};

// CASE : NORMALS OUT OF SPHERE
// Reverse normals
ReverseMesh Surface{116}; // this was done using "-" in Physical Sruface in v2 mesh, in v4 it is not
ReverseMesh Surface{118}; // this was automatic in v2 mesh, in v4 it is not
ReverseMesh Surface{126}; // this was automatic in v2 mesh, in v4 it is not

//Physical surfaces of domain
Physical Surface("outside") = {114, 116, 118, 120, 122, 124, 126, 128};


Field[1] = Ball;
Field[1].Radius = 1.2;
Field[1].Thickness = 0;
Field[1].VIn = sSmall;
Field[1].VOut =sLarge;
Background Field = 1;

//
//Field[1] = Box;
//Field[1].VIn  = sSmall;
//Field[1].VOut = sLarge;
//Field[1].XMin = -2.0;
//Field[1].XMax = +2.0;
//Field[1].YMin = -2.0;
//Field[1].YMax = +2.0;
////Background Field = 1;
//






////+
//Field[1] = MathEval;
////+
//Field[1].F = "50";
////+
//Field[2] = Restrict;
////+
//Field[2].SurfacesList = {114, 116, 118, 120, 122, 124, 126, 128};
////+
//Field[3] = MathEval;
////+
//Field[3].F = "0.1";
////+
//Field[4] = Restrict;
////+
//Field[4].SurfacesList = {2, 3, 4};
////+
//Field[5] = Min;
////+
//Field[5].FieldsList = {2, 4};
////+
//Background Field = 5;
////+
//
//Field[1] = Ball;
//Field[1].Radius = 10;
//Field[1].Thickness = 0;
//Field[1].VIn = 0.1;
//Field[1].VOut = 50.1;
////
//Field[2] = Restrict;
//Field[2].SurfacesList = {2, 3, 4, 114, 116, 118, 120, 122, 124, 126, 128};
//
//Field[3] = Ball;
//Field[3].Radius = 500;
//Field[3].Thickness = 100;
//Field[3].VIn = 50.1;
//Field[3].VOut = 50.1;
//
//Field[4] = Restrict;
//Field[4].SurfacesList = {114, 116, 118, 120, 122, 124, 126, 128};



Mesh.MeshSizeFromPoints = 0.0;
Mesh.MeshSizeFromCurvature = 0.0;
Mesh.MeshSizeExtendFromBoundary = 0.0;